/****************************************************************************
**
** Copyright (C) 2015 The Qt Company Ltd.
**
** This file is part of the QtCore module of the Katie Toolkit.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and The Qt Company. For licensing terms
** and conditions see http://www.qt.io/terms-conditions. For further
** information use the contact form at http://www.qt.io/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 or version 3 as published by the Free
** Software Foundation and appearing in the file LICENSE.LGPLv21 and
** LICENSE.LGPLv3 included in the packaging of this file. Please review the
** following information to ensure the GNU Lesser General Public License
** requirements will be met: https://www.gnu.org/licenses/lgpl.html and
** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** As a special exception, The Qt Company gives you certain additional
** rights. These rights are described in The Qt Company LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
** $QT_END_LICENSE$
**
****************************************************************************/

//
//  W A R N I N G
//  -------------
//
// This file is not part of the Katie API.  It exists for the convenience
// of other Qt classes.  This header file may change from version to
// version without notice, or even be removed.
//
// We mean it.
//

// This file was generated by qlalr - DO NOT EDIT!
#ifndef QSCRIPT_CPP
#define QSCRIPT_CPP

#if defined(ERROR)
#  undef ERROR
#endif

class QScriptGrammar
{
public:
  enum VariousConstants {
    EOF_SYMBOL = 0,
    T_AND = 1,
    T_AND_AND = 2,
    T_AND_EQ = 3,
    T_AUTOMATIC_SEMICOLON = 62,
    T_BREAK = 4,
    T_CASE = 5,
    T_CATCH = 6,
    T_COLON = 7,
    T_COMMA = 8,
    T_CONST = 81,
    T_CONTINUE = 9,
    T_DEBUGGER = 82,
    T_DEFAULT = 10,
    T_DELETE = 11,
    T_DIVIDE_ = 12,
    T_DIVIDE_EQ = 13,
    T_DO = 14,
    T_DOT = 15,
    T_ELSE = 16,
    T_EQ = 17,
    T_EQ_EQ = 18,
    T_EQ_EQ_EQ = 19,
    T_FALSE = 80,
    T_FINALLY = 20,
    T_FOR = 21,
    T_FUNCTION = 22,
    T_GE = 23,
    T_GT = 24,
    T_GT_GT = 25,
    T_GT_GT_EQ = 26,
    T_GT_GT_GT = 27,
    T_GT_GT_GT_EQ = 28,
    T_IDENTIFIER = 29,
    T_IF = 30,
    T_IN = 31,
    T_INSTANCEOF = 32,
    T_LBRACE = 33,
    T_LBRACKET = 34,
    T_LE = 35,
    T_LPAREN = 36,
    T_LT = 37,
    T_LT_LT = 38,
    T_LT_LT_EQ = 39,
    T_MINUS = 40,
    T_MINUS_EQ = 41,
    T_MINUS_MINUS = 42,
    T_NEW = 43,
    T_NOT = 44,
    T_NOT_EQ = 45,
    T_NOT_EQ_EQ = 46,
    T_NULL = 78,
    T_NUMERIC_LITERAL = 47,
    T_OR = 48,
    T_OR_EQ = 49,
    T_OR_OR = 50,
    T_PLUS = 51,
    T_PLUS_EQ = 52,
    T_PLUS_PLUS = 53,
    T_QUESTION = 54,
    T_RBRACE = 55,
    T_RBRACKET = 56,
    T_REMAINDER = 57,
    T_REMAINDER_EQ = 58,
    T_RESERVED_WORD = 83,
    T_RETURN = 59,
    T_RPAREN = 60,
    T_SEMICOLON = 61,
    T_STAR = 63,
    T_STAR_EQ = 64,
    T_STRING_LITERAL = 65,
    T_SWITCH = 66,
    T_THIS = 67,
    T_THROW = 68,
    T_TILDE = 69,
    T_TRUE = 79,
    T_TRY = 70,
    T_TYPEOF = 71,
    T_VAR = 72,
    T_VOID = 73,
    T_WHILE = 74,
    T_WITH = 75,
    T_XOR = 76,
    T_XOR_EQ = 77,

    ACCEPT_STATE = 236,
    RULE_COUNT = 267,
    STATE_COUNT = 465,
    TERMINAL_COUNT = 84,
    NON_TERMINAL_COUNT = 88,

    GOTO_INDEX_OFFSET = 465,
    GOTO_INFO_OFFSET = 1373,
    GOTO_CHECK_OFFSET = 1373
  };

  static const char  *const    spell [];
  static const short             lhs [];
  static const short             rhs [];
  static const short    goto_default [];
  static const short  action_default [];
  static const short    action_index [];
  static const short     action_info [];
  static const short    action_check [];

  static inline int nt_action (int state, int nt)
  {
    const int yyn = action_index [GOTO_INDEX_OFFSET + state] + nt;
    if (yyn < 0 || action_check [GOTO_CHECK_OFFSET + yyn] != nt)
      return goto_default [nt];

    return action_info [GOTO_INFO_OFFSET + yyn];
  }

  static inline int t_action (int state, int token)
  {
    const int yyn = action_index [state] + token;

    if (yyn < 0 || action_check [yyn] != token)
      return - action_default [state];

    return action_info [yyn];
  }
};


const char *const QScriptGrammar::spell [] = {
  "end of file", "&", "&&", "&=", "break", "case", "catch", ":", ";", "continue", 
  "default", "delete", "/", "/=", "do", ".", "else", "=", "==", "===", 
  "finally", "for", "function", ">=", ">", ">>", ">>=", ">>>", ">>>=", "identifier", 
  "if", "in", "instanceof", "{", "[", "<=", "(", "<", "<<", "<<=", 
  "-", "-=", "--", "new", "!", "!=", "!==", "numeric literal", "|", "|=", 
  "||", "+", "+=", "++", "?", "}", "]", "%", "%=", "return", 
  ")", ";", 0, "*", "*=", "string literal", "switch", "this", "throw", "~", 
  "try", "typeof", "var", "void", "while", "with", "^", "^=", "null", "true", 
  "false", "const", "debugger", "reserved word"};

const short QScriptGrammar::lhs [] = {
  85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 
  85, 85, 85, 85, 87, 87, 91, 91, 86, 86, 
  92, 92, 93, 93, 93, 93, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 94, 94, 94, 
  94, 94, 94, 94, 94, 94, 94, 95, 95, 96, 
  96, 96, 96, 96, 99, 99, 100, 100, 100, 100, 
  98, 98, 101, 101, 102, 102, 103, 103, 103, 104, 
  104, 104, 104, 104, 104, 104, 104, 104, 104, 105, 
  105, 105, 105, 106, 106, 106, 107, 107, 107, 107, 
  108, 108, 108, 108, 108, 108, 108, 109, 109, 109, 
  109, 109, 109, 110, 110, 110, 110, 110, 111, 111, 
  111, 111, 111, 112, 112, 113, 113, 114, 114, 115, 
  115, 116, 116, 117, 117, 118, 118, 119, 119, 120, 
  120, 121, 121, 122, 122, 123, 123, 90, 90, 124, 
  124, 125, 125, 125, 125, 125, 125, 125, 125, 125, 
  125, 125, 125, 89, 89, 126, 126, 127, 127, 128, 
  128, 129, 129, 129, 129, 129, 129, 129, 129, 129, 
  129, 129, 129, 129, 129, 129, 130, 146, 146, 145, 
  145, 131, 131, 147, 147, 148, 148, 150, 150, 149, 
  151, 154, 152, 152, 155, 153, 153, 132, 133, 133, 
  134, 134, 135, 135, 135, 135, 135, 135, 135, 136, 
  136, 136, 136, 137, 137, 137, 137, 138, 138, 139, 
  141, 156, 156, 159, 159, 157, 157, 160, 158, 140, 
  142, 142, 143, 143, 143, 161, 162, 144, 163, 97, 
  167, 167, 164, 164, 165, 165, 168, 84, 169, 169, 
  170, 170, 166, 166, 88, 88, 171};

const short QScriptGrammar::rhs [] = {
  1, 1, 1, 1, 1, 1, 1, 1, 1, 3, 
  3, 5, 3, 3, 2, 4, 1, 2, 0, 1, 
  3, 5, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 4, 3, 3, 1, 2, 2, 2, 4, 3, 
  2, 3, 1, 3, 1, 1, 1, 2, 2, 1, 
  2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 
  3, 3, 3, 1, 3, 3, 1, 3, 3, 3, 
  1, 3, 3, 3, 3, 3, 3, 1, 3, 3, 
  3, 3, 3, 1, 3, 3, 3, 3, 1, 3, 
  3, 3, 3, 1, 3, 1, 3, 1, 3, 1, 
  3, 1, 3, 1, 3, 1, 3, 1, 3, 1, 
  3, 1, 3, 1, 5, 1, 5, 1, 3, 1, 
  3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 3, 0, 1, 1, 3, 0, 
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
  1, 1, 1, 1, 1, 1, 3, 1, 2, 0, 
  1, 3, 3, 1, 1, 1, 3, 1, 3, 2, 
  2, 2, 0, 1, 2, 0, 1, 1, 2, 2, 
  7, 5, 7, 7, 5, 9, 10, 7, 8, 2, 
  2, 3, 3, 2, 2, 3, 3, 3, 3, 5, 
  5, 3, 5, 1, 2, 0, 1, 4, 3, 3, 
  3, 3, 3, 3, 4, 5, 2, 1, 8, 8, 
  1, 3, 0, 1, 0, 1, 1, 1, 1, 2, 
  1, 1, 0, 1, 0, 1, 2};

const short QScriptGrammar::action_default [] = {
  0, 97, 164, 128, 136, 132, 172, 179, 76, 148, 
  178, 186, 174, 124, 0, 175, 262, 61, 176, 177, 
  182, 77, 140, 144, 65, 94, 75, 80, 60, 0, 
  114, 180, 101, 259, 258, 261, 183, 0, 194, 0, 
  248, 0, 8, 9, 0, 5, 0, 263, 2, 0, 
  265, 19, 0, 0, 0, 0, 0, 3, 6, 0, 
  0, 166, 208, 7, 0, 1, 0, 0, 4, 0, 
  0, 195, 0, 0, 0, 184, 185, 90, 0, 173, 
  181, 0, 0, 77, 96, 263, 2, 265, 79, 78, 
  0, 0, 0, 92, 93, 91, 0, 264, 253, 254, 
  0, 251, 0, 252, 0, 255, 256, 0, 257, 250, 
  260, 0, 266, 0, 26, 27, 28, 29, 30, 31, 
  32, 33, 34, 35, 36, 37, 38, 39, 40, 23, 
  41, 42, 43, 44, 45, 25, 46, 47, 24, 48, 
  49, 50, 51, 52, 53, 54, 55, 56, 57, 0, 
  21, 0, 0, 0, 22, 13, 95, 0, 125, 0, 
  0, 0, 0, 115, 0, 0, 0, 0, 0, 0, 
  105, 0, 0, 0, 99, 100, 98, 103, 107, 106, 
  104, 102, 117, 116, 118, 0, 133, 0, 129, 68, 
  0, 0, 0, 70, 59, 58, 0, 0, 69, 165, 
  0, 73, 71, 0, 72, 74, 209, 210, 0, 161, 
  154, 152, 159, 160, 158, 157, 163, 156, 155, 153, 
  162, 149, 0, 137, 0, 0, 141, 0, 0, 145, 
  67, 0, 0, 63, 0, 62, 267, 224, 0, 225, 
  226, 227, 220, 0, 221, 222, 223, 81, 0, 0, 
  0, 0, 0, 213, 214, 170, 168, 130, 138, 134, 
  150, 126, 171, 0, 77, 142, 146, 119, 108, 0, 
  0, 127, 0, 0, 0, 0, 120, 0, 0, 0, 
  0, 0, 112, 110, 113, 111, 109, 122, 121, 123, 
  0, 135, 0, 131, 0, 169, 77, 0, 151, 166, 
  167, 0, 166, 0, 0, 216, 0, 0, 0, 218, 
  0, 139, 0, 0, 143, 0, 0, 147, 206, 0, 
  198, 207, 201, 0, 205, 0, 166, 199, 0, 166, 
  0, 0, 217, 0, 0, 0, 219, 264, 253, 0, 
  0, 255, 0, 249, 0, 240, 0, 0, 0, 212, 
  0, 211, 188, 191, 0, 27, 30, 31, 248, 34, 
  35, 5, 39, 40, 2, 41, 44, 3, 6, 166, 
  7, 48, 1, 50, 4, 52, 53, 54, 55, 56, 
  57, 189, 187, 65, 66, 64, 0, 228, 229, 0, 
  0, 0, 231, 236, 234, 237, 0, 0, 235, 236, 
  0, 232, 0, 233, 190, 239, 0, 190, 238, 0, 
  241, 242, 0, 190, 243, 244, 0, 0, 245, 0, 
  0, 0, 246, 247, 83, 82, 0, 0, 0, 215, 
  0, 0, 0, 230, 0, 20, 0, 17, 19, 11, 
  0, 16, 12, 18, 15, 10, 0, 14, 87, 85, 
  89, 86, 84, 88, 203, 196, 0, 204, 200, 0, 
  202, 192, 0, 193, 197};

const short QScriptGrammar::goto_default [] = {
  29, 28, 436, 434, 113, 14, 2, 435, 112, 111, 
  114, 193, 24, 17, 189, 26, 8, 200, 21, 27, 
  77, 25, 1, 32, 30, 267, 13, 261, 3, 257, 
  5, 259, 4, 258, 22, 265, 23, 266, 9, 260, 
  256, 297, 386, 262, 263, 35, 6, 79, 12, 15, 
  18, 19, 10, 7, 31, 80, 20, 36, 75, 76, 
  11, 354, 353, 78, 456, 455, 319, 320, 458, 322, 
  457, 321, 392, 396, 399, 395, 394, 414, 415, 16, 
  100, 107, 96, 99, 106, 108, 33, 0};

const short QScriptGrammar::action_index [] = {
  1209, 57, -84, 12, -39, -43, -84, -84, 108, -84, 
  -84, -84, -84, 195, 194, -84, -84, -84, -84, -84, 
  -84, 333, 35, 86, 176, 166, -84, -84, -84, 6, 
  274, -84, 233, -84, 1209, -84, -84, 164, -84, 170, 
  -84, 520, -84, -84, 1129, -84, 50, 44, 65, -25, 
  1289, 62, 520, 520, 520, 366, 520, -84, -84, 520, 
  520, 520, -84, -84, 46, -84, 520, 520, -84, 14, 
  520, -84, 520, 17, 20, -84, -84, -84, 9, -84, 
  -84, 520, 520, 69, 167, 23, -84, 1049, -84, -84, 
  520, 520, 520, -84, -84, -84, 24, -84, 32, 43, 
  -6, -84, 33, -84, 30, 1209, -84, 11, 1209, -84, 
  -84, 48, 56, 28, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, 520, 
  -84, 1049, 41, 520, -84, -84, 141, 520, 197, 520, 
  520, 520, 520, 284, 520, 520, 520, 520, 520, 520, 
  125, 520, 520, 520, 78, 77, 73, 142, 143, 149, 
  150, 158, 264, 254, 244, 520, -26, 520, 89, -84, 
  969, 520, 889, -84, -84, -84, 104, 520, -84, -84, 
  101, -84, -84, 520, -84, -84, -84, -84, 520, -84, 
  -84, -84, -84, -84, -84, -84, -84, -84, -84, -84, 
  -84, -84, 520, 29, 520, 520, 74, 42, 520, -84, 
  -84, 969, 520, -84, 102, -84, -84, -84, 103, -84, 
  -84, -84, -84, 94, -84, -84, -84, -84, -38, -4, 
  520, 106, 70, -84, -84, 593, -84, 27, -21, -62, 
  -84, 199, 13, -37, 377, 98, 80, 229, 159, -14, 
  520, 190, 520, 520, 520, 520, 294, 520, 520, 520, 
  520, 520, 233, 233, 233, 233, 233, 294, 294, 214, 
  520, -66, 520, 4, 520, -84, 447, 520, -84, 520, 
  -5, -61, 520, -48, 1129, -84, 520, 85, 1129, -84, 
  520, -40, 520, 520, 2, 19, 520, -84, 18, 93, 
  3, -84, -84, 520, -84, 1, 520, -84, -36, 520, 
  -41, 1129, -84, 520, 99, 1129, -84, -20, -12, -42, 
  -13, 1209, -33, -84, 1129, -84, 520, 88, 1129, 15, 
  1129, -84, -84, 1129, -53, 160, -28, 133, 16, 520, 
  1129, 71, 51, 66, 68, 49, 291, 64, 67, 816, 
  61, 45, 60, 520, 72, 47, 520, 63, 520, 53, 
  52, -84, -84, 156, -84, -84, 54, -84, -84, 520, 
  83, 7, -84, 34, -84, 36, 84, 520, -84, 38, 
  39, -84, -11, -84, 1129, -84, 96, 1129, -84, 111, 
  -84, -84, 100, 1129, 22, -84, 21, 25, -84, 40, 
  5, 26, -84, -84, -84, -84, 520, 91, 1129, -84, 
  520, 97, 1129, -84, 90, 37, 739, -84, 76, -84, 
  666, -84, -84, -84, -84, -84, 174, -84, -84, -84, 
  -84, -84, -84, -84, -10, -84, 139, -84, -84, 520, 
  -84, -84, 0, -84, -84, 

  -80, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -26, -88, -88, 4, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -72, -88, -88, -88, -88, -88, 
  -88, 128, -88, -88, -21, -88, -88, -88, -88, -88, 
  -44, -88, 3, 96, 91, 95, 88, -88, -88, 97, 
  104, 6, -88, -88, -88, -88, -5, 73, -88, 12, 
  109, -88, 84, -88, -88, -88, -88, -88, -88, -88, 
  -88, 135, 129, -88, -88, -88, -88, -88, -88, -88, 
  47, 52, 53, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -38, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, 41, 
  -88, 48, -88, -4, -88, -88, -88, 94, -88, 101, 
  137, 142, 140, -88, 117, 131, 120, 119, 118, 82, 
  -88, 57, 58, 60, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, 59, -88, 69, -88, -88, 
  21, 27, -2, -88, -88, -88, -88, 0, -88, -88, 
  -88, -88, -88, 20, -88, -88, -88, -88, 13, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, 56, -88, 51, 19, -88, -88, 22, -88, 
  -88, 134, 30, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  39, -88, -88, -88, -88, 139, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  189, -88, 181, 175, 172, 171, -88, 72, 80, 76, 
  63, 43, -88, -88, -88, -88, -88, -88, -88, -88, 
  154, -88, 153, -88, 152, -88, -88, 151, -88, 50, 
  -88, -88, 54, -88, 15, -88, 46, -88, 9, -88, 
  155, -88, 230, 161, -88, -88, 163, -88, -88, -88, 
  -88, -88, -88, 187, -88, -22, 79, -88, -88, 160, 
  -88, 8, -88, 38, -88, 7, -88, -88, -39, -88, 
  -88, -41, -88, -88, -8, -88, 33, -88, -6, -88, 
  -3, -88, -88, 1, -88, -88, -88, -88, -88, 114, 
  -9, -88, -88, -88, -88, -88, 111, -88, -88, 45, 
  -88, -88, -88, 44, -88, 10, 110, -88, 113, -88, 
  -88, -88, -88, -1, -88, -88, -88, -88, -88, 5, 
  -88, -88, -88, -88, -88, -67, -88, 2, -88, -70, 
  -88, -88, -88, -88, 107, -88, -88, 106, -88, -88, 
  -88, -88, -88, -12, -48, -88, -88, -17, -88, -88, 
  -88, -19, -88, -88, -88, -88, 18, -88, -23, -88, 
  16, -88, -25, -88, -88, -88, 11, -88, 14, -88, 
  77, -88, -88, -88, -88, -88, -88, -88, -88, -88, 
  -88, -88, -88, -88, -88, -88, -88, -88, -88, 28, 
  -88, -88, -53, -88, -88};

const short QScriptGrammar::action_info [] = {
  302, -194, 382, 197, 310, 270, 236, 459, 290, 185, 
  292, 346, 304, 157, 292, 318, 338, 101, 340, 331, 
  341, 294, 343, -32, 299, 329, 316, 290, 270, 454, 
  318, 350, 250, 187, 333, 323, 249, 222, 454, 397, 
  393, 397, 417, 397, 403, 443, 404, 413, 153, 228, 
  187, 102, 97, 426, 104, 149, 430, 419, 413, 413, 
  98, 101, 103, 105, 151, 421, 109, -49, -24, 420, 
  437, -45, 344, 337, -25, 344, 222, 185, -37, -51, 
  413, 389, 389, 155, 437, 346, 255, 255, 430, 426, 
  157, 197, -195, 197, 400, 97, 197, 81, 438, 197, 
  310, 325, -263, 407, 197, 197, 416, 197, 82, 203, 
  197, 88, 197, 81, 197, 388, 387, 81, 81, 197, 
  417, 0, 89, 190, 82, 0, 0, 0, 82, 82, 
  312, 254, 253, 0, 313, 0, 224, 0, 0, 401, 
  225, 0, 191, 391, 192, 308, 439, 462, 348, 0, 
  171, 428, 172, 90, 326, 246, 245, 432, 235, 335, 
  198, 204, 243, 173, 241, 240, 252, 171, 171, 172, 
  172, 231, 411, 410, 171, 171, 172, 172, 90, 90, 
  173, 173, 197, 171, 171, 172, 172, 173, 173, 238, 
  232, 231, 192, 238, 244, 242, 173, 173, 91, 243, 
  463, 461, 197, 0, 92, 0, 0, 0, 272, 273, 
  232, 0, 192, 159, 160, 159, 160, 272, 273, 0, 
  0, 239, 237, 91, 91, 239, 237, 0, 0, 92, 
  92, 244, 242, 0, 447, 274, 275, 277, 278, 0, 
  161, 162, 161, 162, 274, 275, 279, 0, 0, 280, 
  0, 281, 277, 278, 0, 207, 206, 0, 171, 0, 
  172, 279, 0, 0, 280, 0, 281, 164, 165, 0, 
  0, 173, 0, 0, 0, 166, 167, 164, 165, 168, 
  0, 169, 0, 0, 0, 166, 167, 164, 165, 168, 
  0, 169, 0, 0, 0, 166, 167, 164, 165, 168, 
  0, 169, 0, 42, 43, 166, 167, 164, 165, 168, 
  0, 169, 0, 85, 0, 166, 167, 277, 278, 168, 
  86, 169, 0, 0, 87, 51, 279, 52, 0, 280, 
  0, 281, 0, 0, 55, 0, 209, 0, 58, 0, 
  0, 0, 0, 0, 0, 0, 210, 0, 0, 0, 
  211, 0, 0, 0, 0, 0, 63, 0, 65, 212, 
  0, 213, 0, 0, 0, 0, 0, 0, 0, 57, 
  68, 45, 214, 0, 215, 88, 0, 0, 42, 43, 
  209, 0, 216, 0, 0, 217, 89, 0, 85, 0, 
  210, 218, 0, 0, 211, 86, 0, 219, 0, 87, 
  51, 0, 52, 212, 0, 213, 0, 0, 306, 55, 
  220, 0, 0, 58, 0, 0, 214, 0, 215, 88, 
  0, 0, 0, 0, 0, 0, 216, 0, 0, 217, 
  89, 63, 0, 65, 0, 218, 0, 0, 0, 0, 
  0, 219, 0, 0, 57, 68, 45, 0, 0, 0, 
  209, 0, 0, 0, 220, 0, 0, 0, 0, 0, 
  210, 0, 0, 0, 211, 0, 0, 0, 0, 0, 
  0, 0, 0, 212, 0, 213, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 214, 0, 215, 88, 
  0, 0, 0, 0, 0, 0, 216, 0, 0, 217, 
  89, 0, 0, 0, 0, 218, 0, 0, 0, 0, 
  0, 219, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 220, 0, 0, 0, 0, 0, 
  0, 41, 42, 43, 0, 0, 0, 0, 0, 0, 
  0, 0, 85, 0, 0, 0, 0, 0, 0, 86, 
  0, 0, 0, 87, 51, 0, 52, 0, 0, 0, 
  53, 0, 54, 55, 56, 0, 0, 58, 0, 0, 
  0, 59, 0, 60, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 63, 0, 65, 0, 67, 
  0, 70, 0, 72, 0, 0, 0, 0, 57, 68, 
  45, 0, 0, 0, 41, 42, 43, 0, 0, 0, 
  0, 0, 0, 0, 0, 85, 0, 0, 0, 0, 
  0, 0, 86, 0, 0, 0, 87, 51, 0, 52, 
  0, 0, 0, 53, 0, 54, 55, 56, 0, 0, 
  58, 0, 0, 0, 59, 0, 60, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 63, 0, 
  65, 0, 67, 0, 70, 269, 72, 0, 0, 0, 
  0, 57, 68, 45, 0, 0, 0, 41, 42, 43, 
  0, 0, 0, 0, 0, 0, 0, 0, 85, 0, 
  0, 0, 0, 0, 0, 86, 0, 0, 0, 87, 
  51, 0, 52, 0, 0, 0, 53, 0, 54, 55, 
  56, 0, 0, 58, 0, 0, 0, 59, 0, 60, 
  0, 0, 442, 0, 0, 0, 0, 0, 0, 0, 
  0, 63, 0, 65, 0, 67, 0, 70, 0, 72, 
  0, 0, 0, 0, 57, 68, 45, 0, 0, 0, 
  41, 42, 43, 0, 0, 0, 0, 0, 0, 0, 
  0, 85, 0, 0, 0, 0, 0, 0, 86, 0, 
  0, 0, 87, 51, 0, 52, 0, 0, 0, 53, 
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0, 
  59, 0, 60, 0, 0, 445, 0, 0, 0, 0, 
  0, 0, 0, 0, 63, 0, 65, 0, 67, 0, 
  70, 0, 72, 0, 0, 0, 0, 57, 68, 45, 
  0, 0, 0, -47, 0, 0, 0, 41, 42, 43, 
  0, 0, 0, 0, 0, 0, 0, 0, 85, 0, 
  0, 0, 0, 0, 0, 86, 0, 0, 0, 87, 
  51, 0, 52, 0, 0, 0, 53, 0, 54, 55, 
  56, 0, 0, 58, 0, 0, 0, 59, 0, 60, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 63, 0, 65, 0, 67, 0, 70, 0, 72, 
  0, 0, 0, 0, 57, 68, 45, 0, 0, 0, 
  41, 42, 43, 0, 0, 0, 0, 0, 0, 0, 
  0, 85, 0, 0, 0, 0, 0, 0, 86, 0, 
  0, 0, 87, 51, 0, 52, 0, 0, 0, 53, 
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0, 
  59, 0, 60, 0, 0, 0, 0, 0, 0, 202, 
  0, 0, 0, 0, 63, 0, 65, 0, 67, 0, 
  70, 0, 72, 0, 0, 0, 0, 57, 68, 45, 
  0, 0, 0, 115, 116, 117, 0, 0, 119, 121, 
  122, 0, 0, 123, 0, 124, 0, 0, 0, 126, 
  127, 128, 0, 0, 0, 0, 0, 0, 195, 130, 
  131, 132, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 133, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 137, 0, 
  0, 0, 0, 0, 0, 139, 140, 141, 0, 143, 
  144, 145, 146, 147, 148, 0, 0, 134, 142, 125, 
  118, 120, 136, 115, 116, 117, 0, 0, 119, 121, 
  122, 0, 0, 123, 0, 124, 0, 0, 0, 126, 
  127, 128, 0, 0, 0, 0, 0, 0, 129, 130, 
  131, 132, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 133, 0, 0, 0, 135, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 137, 0, 
  0, 0, 0, 0, 138, 139, 140, 141, 0, 143, 
  144, 145, 146, 147, 148, 0, 0, 134, 142, 125, 
  118, 120, 136, 37, 0, 0, 0, 0, 39, 0, 
  41, 42, 43, 44, 0, 0, 0, 0, 0, 0, 
  46, 85, 0, 0, 0, 0, 0, 0, 48, 49, 
  0, 0, 50, 51, 0, 52, 0, 0, 0, 53, 
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0, 
  59, 0, 60, 0, 0, 0, 0, 0, 61, 0, 
  62, 0, 0, 0, 63, 64, 65, 66, 67, 69, 
  70, 71, 72, 73, 74, 0, 0, 57, 68, 45, 
  38, 40, 0, 37, 0, 0, 0, 0, 39, 0, 
  41, 42, 43, 44, 0, 0, 0, 0, 0, 0, 
  46, 47, 0, 0, 0, 0, 0, 0, 48, 49, 
  0, 0, 50, 51, 0, 52, 0, 0, 0, 53, 
  0, 54, 55, 56, 0, 0, 58, 0, 0, 0, 
  59, 0, 60, 0, 0, 0, 0, 0, 61, 0, 
  62, 0, 0, 0, 63, 64, 65, 66, 67, 69, 
  70, 71, 72, 73, 74, 0, 0, 57, 68, 45, 
  38, 40, 0, 355, 116, 117, 0, 0, 357, 121, 
  359, 42, 43, 360, 0, 124, 0, 0, 0, 126, 
  362, 363, 0, 0, 0, 0, 0, 0, 364, 365, 
  131, 132, 50, 51, 0, 52, 0, 0, 0, 53, 
  0, 54, 366, 56, 0, 0, 368, 0, 0, 0, 
  59, 0, 60, 0, -190, 0, 0, 0, 369, 0, 
  62, 0, 0, 0, 370, 371, 372, 373, 67, 375, 
  376, 377, 378, 379, 380, 0, 0, 367, 374, 361, 
  356, 358, 136, 

  409, 352, 154, 402, 201, 34, 199, 406, 446, 398, 
  390, 300, 464, 385, 110, 208, 440, 444, 230, 221, 
  433, 431, 429, 427, 248, 227, 205, 422, 229, 423, 
  418, 194, 196, 352, 460, 234, 248, 345, 347, 349, 
  342, 339, 351, 334, 251, 327, 381, 150, 110, 409, 
  300, 307, 336, 332, 309, 300, 412, 152, 412, 300, 
  305, 83, 0, 0, 0, 83, 286, 93, 0, 83, 
  83, 83, 94, 95, 83, 83, 83, 83, 83, 174, 
  175, 83, 176, 441, 300, 226, 285, 83, 223, 186, 
  83, 83, 301, 453, 83, 282, 303, 188, 83, 284, 
  83, 0, 83, 283, 425, 181, 83, 383, 450, 83, 
  384, 449, 83, 0, 83, 83, 448, 451, 0, 83, 
  158, 328, 83, 383, 452, 163, 384, 83, 83, 424, 
  424, 83, 83, 425, 247, 83, 83, 83, 83, 0, 
  170, 180, 179, 178, 194, 233, 83, 83, 247, 83, 
  156, 352, 352, 83, 177, 83, 84, 264, 83, 0, 
  83, 182, 268, 0, 184, 300, 183, 408, 405, 296, 
  296, 83, 83, 83, 268, 268, 268, 268, 268, 296, 
  0, 296, 293, 0, 268, 291, 268, 0, 311, 83, 
  83, 298, 295, 83, 268, 268, 289, 288, 268, 83, 
  287, 315, 330, 317, 268, 296, 276, 83, 0, 0, 
  268, 0, 268, 0, 0, 0, 271, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 324, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 83, 0, 
  0, 0, 0, 268, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 314, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
  0, 0, 0, 0, 0, 0, 0, 0};

const short QScriptGrammar::action_check [] = {
  61, 29, 55, 8, 2, 1, 0, 17, 48, 48, 
  76, 36, 60, 1, 76, 29, 36, 29, 60, 60, 
  33, 8, 55, 7, 61, 61, 7, 48, 1, 29, 
  29, 16, 36, 76, 31, 17, 74, 2, 29, 5, 
  33, 5, 20, 5, 55, 8, 7, 33, 7, 7, 
  76, 8, 29, 36, 60, 7, 36, 36, 33, 33, 
  36, 29, 29, 33, 8, 60, 55, 7, 7, 29, 
  8, 7, 7, 29, 7, 7, 2, 48, 7, 7, 
  33, 36, 36, 55, 8, 36, 36, 36, 36, 36, 
  1, 8, 29, 8, 10, 29, 8, 40, 8, 8, 
  2, 8, 36, 7, 8, 8, 6, 8, 51, 8, 
  8, 42, 8, 40, 8, 61, 62, 40, 40, 8, 
  20, -1, 53, 15, 51, -1, -1, -1, 51, 51, 
  50, 61, 62, -1, 54, -1, 50, -1, -1, 55, 
  54, -1, 34, 60, 36, 60, 56, 8, 60, -1, 
  25, 60, 27, 12, 61, 61, 62, 60, 56, 60, 
  56, 60, 29, 38, 61, 62, 60, 25, 25, 27, 
  27, 15, 61, 62, 25, 25, 27, 27, 12, 12, 
  38, 38, 8, 25, 25, 27, 27, 38, 38, 29, 
  34, 15, 36, 29, 61, 62, 38, 38, 57, 29, 
  61, 62, 8, -1, 63, -1, -1, -1, 18, 19, 
  34, -1, 36, 18, 19, 18, 19, 18, 19, -1, 
  -1, 61, 62, 57, 57, 61, 62, -1, -1, 63, 
  63, 61, 62, -1, 60, 45, 46, 23, 24, -1, 
  45, 46, 45, 46, 45, 46, 32, -1, -1, 35, 
  -1, 37, 23, 24, -1, 61, 62, -1, 25, -1, 
  27, 32, -1, -1, 35, -1, 37, 23, 24, -1, 
  -1, 38, -1, -1, -1, 31, 32, 23, 24, 35, 
  -1, 37, -1, -1, -1, 31, 32, 23, 24, 35, 
  -1, 37, -1, -1, -1, 31, 32, 23, 24, 35, 
  -1, 37, -1, 12, 13, 31, 32, 23, 24, 35, 
  -1, 37, -1, 22, -1, 31, 32, 23, 24, 35, 
  29, 37, -1, -1, 33, 34, 32, 36, -1, 35, 
  -1, 37, -1, -1, 43, -1, 3, -1, 47, -1, 
  -1, -1, -1, -1, -1, -1, 13, -1, -1, -1, 
  17, -1, -1, -1, -1, -1, 65, -1, 67, 26, 
  -1, 28, -1, -1, -1, -1, -1, -1, -1, 78, 
  79, 80, 39, -1, 41, 42, -1, -1, 12, 13, 
  3, -1, 49, -1, -1, 52, 53, -1, 22, -1, 
  13, 58, -1, -1, 17, 29, -1, 64, -1, 33, 
  34, -1, 36, 26, -1, 28, -1, -1, 31, 43, 
  77, -1, -1, 47, -1, -1, 39, -1, 41, 42, 
  -1, -1, -1, -1, -1, -1, 49, -1, -1, 52, 
  53, 65, -1, 67, -1, 58, -1, -1, -1, -1, 
  -1, 64, -1, -1, 78, 79, 80, -1, -1, -1, 
  3, -1, -1, -1, 77, -1, -1, -1, -1, -1, 
  13, -1, -1, -1, 17, -1, -1, -1, -1, -1, 
  -1, -1, -1, 26, -1, 28, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, 39, -1, 41, 42, 
  -1, -1, -1, -1, -1, -1, 49, -1, -1, 52, 
  53, -1, -1, -1, -1, 58, -1, -1, -1, -1, 
  -1, 64, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, 77, -1, -1, -1, -1, -1, 
  -1, 11, 12, 13, -1, -1, -1, -1, -1, -1, 
  -1, -1, 22, -1, -1, -1, -1, -1, -1, 29, 
  -1, -1, -1, 33, 34, -1, 36, -1, -1, -1, 
  40, -1, 42, 43, 44, -1, -1, 47, -1, -1, 
  -1, 51, -1, 53, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, 65, -1, 67, -1, 69, 
  -1, 71, -1, 73, -1, -1, -1, -1, 78, 79, 
  80, -1, -1, -1, 11, 12, 13, -1, -1, -1, 
  -1, -1, -1, -1, -1, 22, -1, -1, -1, -1, 
  -1, -1, 29, -1, -1, -1, 33, 34, -1, 36, 
  -1, -1, -1, 40, -1, 42, 43, 44, -1, -1, 
  47, -1, -1, -1, 51, -1, 53, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, 65, -1, 
  67, -1, 69, -1, 71, 72, 73, -1, -1, -1, 
  -1, 78, 79, 80, -1, -1, -1, 11, 12, 13, 
  -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, 
  -1, -1, -1, -1, -1, 29, -1, -1, -1, 33, 
  34, -1, 36, -1, -1, -1, 40, -1, 42, 43, 
  44, -1, -1, 47, -1, -1, -1, 51, -1, 53, 
  -1, -1, 56, -1, -1, -1, -1, -1, -1, -1, 
  -1, 65, -1, 67, -1, 69, -1, 71, -1, 73, 
  -1, -1, -1, -1, 78, 79, 80, -1, -1, -1, 
  11, 12, 13, -1, -1, -1, -1, -1, -1, -1, 
  -1, 22, -1, -1, -1, -1, -1, -1, 29, -1, 
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40, 
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1, 
  51, -1, 53, -1, -1, 56, -1, -1, -1, -1, 
  -1, -1, -1, -1, 65, -1, 67, -1, 69, -1, 
  71, -1, 73, -1, -1, -1, -1, 78, 79, 80, 
  -1, -1, -1, 7, -1, -1, -1, 11, 12, 13, 
  -1, -1, -1, -1, -1, -1, -1, -1, 22, -1, 
  -1, -1, -1, -1, -1, 29, -1, -1, -1, 33, 
  34, -1, 36, -1, -1, -1, 40, -1, 42, 43, 
  44, -1, -1, 47, -1, -1, -1, 51, -1, 53, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, 65, -1, 67, -1, 69, -1, 71, -1, 73, 
  -1, -1, -1, -1, 78, 79, 80, -1, -1, -1, 
  11, 12, 13, -1, -1, -1, -1, -1, -1, -1, 
  -1, 22, -1, -1, -1, -1, -1, -1, 29, -1, 
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40, 
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1, 
  51, -1, 53, -1, -1, -1, -1, -1, -1, 60, 
  -1, -1, -1, -1, 65, -1, 67, -1, 69, -1, 
  71, -1, 73, -1, -1, -1, -1, 78, 79, 80, 
  -1, -1, -1, 4, 5, 6, -1, -1, 9, 10, 
  11, -1, -1, 14, -1, 16, -1, -1, -1, 20, 
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30, 
  31, 32, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, 43, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, 
  -1, -1, -1, -1, -1, 66, 67, 68, -1, 70, 
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80, 
  81, 82, 83, 4, 5, 6, -1, -1, 9, 10, 
  11, -1, -1, 14, -1, 16, -1, -1, -1, 20, 
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30, 
  31, 32, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, 43, -1, -1, -1, 47, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, 59, -1, 
  -1, -1, -1, -1, 65, 66, 67, 68, -1, 70, 
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80, 
  81, 82, 83, 4, -1, -1, -1, -1, 9, -1, 
  11, 12, 13, 14, -1, -1, -1, -1, -1, -1, 
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30, 
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40, 
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1, 
  51, -1, 53, -1, -1, -1, -1, -1, 59, -1, 
  61, -1, -1, -1, 65, 66, 67, 68, 69, 70, 
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80, 
  81, 82, -1, 4, -1, -1, -1, -1, 9, -1, 
  11, 12, 13, 14, -1, -1, -1, -1, -1, -1, 
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30, 
  -1, -1, 33, 34, -1, 36, -1, -1, -1, 40, 
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1, 
  51, -1, 53, -1, -1, -1, -1, -1, 59, -1, 
  61, -1, -1, -1, 65, 66, 67, 68, 69, 70, 
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80, 
  81, 82, -1, 4, 5, 6, -1, -1, 9, 10, 
  11, 12, 13, 14, -1, 16, -1, -1, -1, 20, 
  21, 22, -1, -1, -1, -1, -1, -1, 29, 30, 
  31, 32, 33, 34, -1, 36, -1, -1, -1, 40, 
  -1, 42, 43, 44, -1, -1, 47, -1, -1, -1, 
  51, -1, 53, -1, 55, -1, -1, -1, 59, -1, 
  61, -1, -1, -1, 65, 66, 67, 68, 69, 70, 
  71, 72, 73, 74, 75, -1, -1, 78, 79, 80, 
  81, 82, 83, 

  5, 45, 6, 73, 6, 85, 6, 5, 5, 76, 
  5, 5, 65, 14, 86, 41, 2, 6, 14, 6, 
  45, 5, 45, 5, 45, 6, 6, 46, 6, 46, 
  78, 10, 5, 45, 6, 5, 45, 45, 5, 45, 
  81, 80, 45, 5, 5, 67, 45, 6, 86, 5, 
  5, 5, 45, 45, 45, 5, 46, 9, 46, 5, 
  45, 18, -1, -1, -1, 18, 23, 20, -1, 18, 
  18, 18, 20, 20, 18, 18, 18, 18, 18, 22, 
  22, 18, 22, 6, 5, 34, 23, 18, 32, 30, 
  18, 18, 42, 20, 18, 23, 42, 28, 18, 23, 
  18, -1, 18, 23, 20, 23, 18, 12, 20, 18, 
  15, 20, 18, -1, 18, 18, 20, 20, -1, 18, 
  26, 42, 18, 12, 20, 24, 15, 18, 18, 20, 
  20, 18, 18, 20, 20, 18, 18, 18, 18, -1, 
  23, 23, 23, 23, 10, 11, 18, 18, 20, 18, 
  21, 45, 45, 18, 23, 18, 21, 18, 18, -1, 
  18, 24, 23, -1, 24, 5, 24, 61, 61, 18, 
  18, 18, 18, 18, 23, 23, 23, 23, 23, 18, 
  -1, 18, 29, -1, 23, 31, 23, -1, 33, 18, 
  18, 40, 40, 18, 23, 23, 25, 25, 23, 18, 
  25, 40, 42, 40, 23, 18, 25, 18, -1, -1, 
  23, -1, 23, -1, -1, -1, 27, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, 40, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, 18, -1, 
  -1, -1, -1, 23, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, 35, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
  -1, -1, -1, -1, -1, -1, -1, -1};


#define Q_SCRIPT_REGEXPLITERAL_RULE1 7

#define Q_SCRIPT_REGEXPLITERAL_RULE2 8

#include <lupdate.h>
#include <translator.h>

#include <QtCore/QCoreApplication>
#include <QtCore/qdebug.h>
#include <QtCore/qnumeric.h>
#include <QtCore/qstring.h>
#include <QtCore/qtextcodec.h>
#include <QtCore/qvariant.h>

#include <iostream>

#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

QT_BEGIN_NAMESPACE

static void recordMessage(
    Translator *tor, const QString &context, const QString &text, const QString &comment,
    const QString &extracomment, const QString &msgid, const TranslatorMessage::ExtraData &extra,
    bool plural, const QString &fileName, int lineNo)
{
    TranslatorMessage msg(
        context, text, comment, QString(),
        fileName, lineNo, QStringList(),
        TranslatorMessage::Unfinished, plural);
    msg.setExtraComment(extracomment.simplified());
    msg.setId(msgid);
    msg.setExtras(extra);
    tor->extend(msg);
}


namespace QScript
{

class CommentProcessor
{
public:
    virtual ~CommentProcessor() {}
    virtual void processComment(const QChar *chars, int length) = 0;
};

class Lexer
{
public:
    Lexer(CommentProcessor *);
    ~Lexer();

    void setCode(const QString &c, const QString &fileName, int lineno);
    int lex();

    QString fileName() const { return yyfilename; }
    int currentLineNo() const { return yylineno; }
    int currentColumnNo() const { return yycolumn; }

    int startLineNo() const { return startlineno; }
    int startColumnNo() const { return startcolumn; }

    int endLineNo() const { return currentLineNo(); }
    int endColumnNo() const
    { int col = currentColumnNo(); return (col > 0) ? col - 1 : col; }

    bool prevTerminator() const { return terminator; }

    enum State { Start,
                 Identifier,
                 InIdentifier,
                 InSingleLineComment,
                 InMultiLineComment,
                 InNum,
                 InNum0,
                 InHex,
                 InOctal,
                 InDecimal,
                 InExponentIndicator,
                 InExponent,
                 Hex,
                 Octal,
                 Number,
                 String,
                 Eof,
                 InString,
                 InEscapeSequence,
                 InHexEscape,
                 InUnicodeEscape,
                 Other,
                 Bad };

    enum Error {
        NoError,
        IllegalCharacter,
        UnclosedStringLiteral,
        IllegalEscapeSequence,
        IllegalUnicodeEscapeSequence,
        UnclosedComment,
        IllegalExponentIndicator,
        IllegalIdentifier
    };

    enum ParenthesesState {
        IgnoreParentheses,
        CountParentheses,
        BalancedParentheses
    };

    enum RegExpBodyPrefix {
        NoPrefix,
        EqualPrefix
    };

    bool scanRegExp(RegExpBodyPrefix prefix = NoPrefix);

    QString pattern;
    int flags;

    State lexerState() const
        { return state; }

    QString errorMessage() const
        { return errmsg; }
    void setErrorMessage(const QString &err)
        { errmsg = err; }
    void setErrorMessage(const char *err)
        { setErrorMessage(QString::fromLatin1(err)); }

    Error error() const
        { return err; }
    void clearError()
        { err = NoError; }

private:
    QString yyfilename;
    int yylineno;
    bool done;
    char *buffer8;
    QChar *buffer16;
    uint size8, size16;
    uint pos8, pos16;
    bool terminator;
    bool restrKeyword;
    // encountered delimiter like "'" and "}" on last run
    bool delimited;
    int stackToken;

    State state;
    void setDone(State s);
    uint pos;
    void shift(uint p);
    int lookupKeyword(const char *);

    bool isWhiteSpace() const;
    bool isLineTerminator() const;
    bool isHexDigit(ushort c) const;
    bool isOctalDigit(ushort c) const;

    int matchPunctuator(ushort c1, ushort c2,
                         ushort c3, ushort c4);
    ushort singleEscape(ushort c) const;
    ushort convertOctal(ushort c1, ushort c2,
                         ushort c3) const;
public:
    static unsigned char convertHex(ushort c1);
    static unsigned char convertHex(ushort c1, ushort c2);
    static QChar convertUnicode(ushort c1, ushort c2,
                                 ushort c3, ushort c4);
    static bool isIdentLetter(ushort c);
    static bool isDecimalDigit(ushort c);

    inline int ival() const { return qsyylval.toInt(); }
    inline double dval() const { return qsyylval.toDouble(); }
    inline QString ustr() const { return qsyylval.toString(); }
    inline QVariant val() const { return qsyylval; }

    const QChar *characterBuffer() const { return buffer16; }
    int characterCount() const { return pos16; }

private:
    void record8(ushort c);
    void record16(QChar c);
    void recordStartPos();

    int findReservedWord(const QChar *buffer, int size) const;

    void syncProhibitAutomaticSemicolon();

    void processComment(const QChar *, int);

    const QChar *code;
    uint length;
    int yycolumn;
    int startlineno;
    int startcolumn;
    int bol;     // begin of line

    QVariant qsyylval;

    // current and following unicode characters
    ushort current, next1, next2, next3;

    struct keyword {
        const char *name;
        int token;
    };

    QString errmsg;
    Error err;

    bool wantRx;
    bool check_reserved;

    ParenthesesState parenthesesState;
    int parenthesesCount;
    bool prohibitAutomaticSemicolon;

    CommentProcessor *commentProcessor;
};

} // namespace QScript

#define shiftWindowsLineBreak() if(current == '\r' && next1 == '\n') shift(1);

namespace QScript {

static int toDigit(char c)
{
    if ((c >= '0') && (c <= '9'))
        return c - '0';
    else if ((c >= 'a') && (c <= 'z'))
        return 10 + c - 'a';
    else if ((c >= 'A') && (c <= 'Z'))
        return 10 + c - 'A';
    return -1;
}

double integerFromString(const char *buf, int size, int radix)
{
    if (size == 0)
        return qSNaN();

    double sign = 1.0;
    int i = 0;
    if (buf[0] == '+') {
        ++i;
    } else if (buf[0] == '-') {
        sign = -1.0;
        ++i;
    }

    if (((size-i) >= 2) && (buf[i] == '0')) {
        if (((buf[i+1] == 'x') || (buf[i+1] == 'X'))
            && (radix < 34)) {
            if ((radix != 0) && (radix != 16))
                return 0;
            radix = 16;
            i += 2;
        } else {
            if (radix == 0) {
                radix = 8;
                ++i;
            }
        }
    } else if (radix == 0) {
        radix = 10;
    }

    int j = i;
    for ( ; i < size; ++i) {
        int d = toDigit(buf[i]);
        if ((d == -1) || (d >= radix))
            break;
    }
    double result;
    if (j == i) {
        if (!qstrcmp(buf, "Infinity"))
            result = qInf();
        else
            result = qSNaN();
    } else {
        result = 0;
        double multiplier = 1;
        for (--i ; i >= j; --i, multiplier *= radix)
            result += toDigit(buf[i]) * multiplier;
    }
    result *= sign;
    return result;
}

} // namespace QScript

QScript::Lexer::Lexer(QScript::CommentProcessor *proc)
    :
      yylineno(0),
      size8(128), size16(128), restrKeyword(false),
      stackToken(-1), pos(0),
      code(0), length(0),
      bol(true),
      current(0), next1(0), next2(0), next3(0),
      err(NoError),
      check_reserved(true),
      parenthesesState(IgnoreParentheses),
      prohibitAutomaticSemicolon(false),
      commentProcessor(proc)
{
    // allocate space for read buffers
    buffer8 = new char[size8];
    buffer16 = new QChar[size16];
    flags = 0;

}

QScript::Lexer::~Lexer()
{
    delete [] buffer8;
    delete [] buffer16;
}

void QScript::Lexer::setCode(const QString &c, const QString &fileName, int lineno)
{
    errmsg = QString();
    yyfilename = fileName;
    yylineno = lineno;
    yycolumn = 1;
    restrKeyword = false;
    delimited = false;
    stackToken = -1;
    pos = 0;
    code = c.unicode();
    length = c.length();
    bol = true;

    // read first characters
    current = (length > 0) ? code[0].unicode() : 0;
    next1 = (length > 1) ? code[1].unicode() : 0;
    next2 = (length > 2) ? code[2].unicode() : 0;
    next3 = (length > 3) ? code[3].unicode() : 0;
}

void QScript::Lexer::shift(uint p)
{
    while (p--) {
        ++pos;
        ++yycolumn;
        current = next1;
        next1 = next2;
        next2 = next3;
        next3 = (pos + 3 < length) ? code[pos+3].unicode() : 0;
    }
}

void QScript::Lexer::setDone(State s)
{
    state = s;
    done = true;
}

int QScript::Lexer::findReservedWord(const QChar *c, int size) const
{
    switch (size) {
    case 2: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o'))
            return QScriptGrammar::T_DO;
        else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('f'))
            return QScriptGrammar::T_IF;
        else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n'))
            return QScriptGrammar::T_IN;
    }   break;

    case 3: {
        if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('o') && c[2] == QLatin1Char('r'))
            return QScriptGrammar::T_FOR;
        else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('e') && c[2] == QLatin1Char('w'))
            return QScriptGrammar::T_NEW;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r') && c[2] == QLatin1Char('y'))
            return QScriptGrammar::T_TRY;
        else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('a') && c[2] == QLatin1Char('r'))
            return QScriptGrammar::T_VAR;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n') && c[2] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 4: {
        if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_CASE;
        else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('l')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_ELSE;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('s'))
            return QScriptGrammar::T_THIS;
        else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('d'))
            return QScriptGrammar::T_VOID;
        else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('i')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('h'))
            return QScriptGrammar::T_WITH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('e'))
            return QScriptGrammar::T_TRUE;
        else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('u')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('l'))
            return QScriptGrammar::T_NULL;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('n')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('m'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('l') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('g'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('r'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('g') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('o'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 5: {
        if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('r')
                && c[2] == QLatin1Char('e') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('k'))
            return QScriptGrammar::T_BREAK;
        else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('c')
                && c[4] == QLatin1Char('h'))
            return QScriptGrammar::T_CATCH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                && c[4] == QLatin1Char('w'))
            return QScriptGrammar::T_THROW;
        else if (c[0] == QLatin1Char('w') && c[1] == QLatin1Char('h')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('l')
                && c[4] == QLatin1Char('e'))
            return QScriptGrammar::T_WHILE;
        else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('s')
                && c[4] == QLatin1Char('t'))
            return QScriptGrammar::T_CONST;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('a')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('s')
                && c[4] == QLatin1Char('e'))
            return QScriptGrammar::T_FALSE;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('r')
                    && c[4] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('r'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('l'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('s')
                    && c[4] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('l')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 6: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('e')
                && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('e'))
            return QScriptGrammar::T_DELETE;
        else if (c[0] == QLatin1Char('r') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('u')
                && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('n'))
            return QScriptGrammar::T_RETURN;
        else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('w')
                && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('c') && c[5] == QLatin1Char('h'))
            return QScriptGrammar::T_SWITCH;
        else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('y')
                && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('e')
                && c[4] == QLatin1Char('o') && c[5] == QLatin1Char('f'))
            return QScriptGrammar::T_TYPEOF;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('t')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('u') && c[3] == QLatin1Char('b')
                    && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('u')
                    && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('c'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('n') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('i')
                    && c[4] == QLatin1Char('v') && c[5] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('h')
                    && c[2] == QLatin1Char('r') && c[3] == QLatin1Char('o')
                    && c[4] == QLatin1Char('w') && c[5] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 7: {
        if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('f') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('u') && c[5] == QLatin1Char('l')
                && c[6] == QLatin1Char('t'))
            return QScriptGrammar::T_DEFAULT;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('i')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('a')
                && c[4] == QLatin1Char('l') && c[5] == QLatin1Char('l')
                && c[6] == QLatin1Char('y'))
            return QScriptGrammar::T_FINALLY;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('b') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('a')
                    && c[6] == QLatin1Char('n'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('e') && c[1] == QLatin1Char('x')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('n') && c[5] == QLatin1Char('d')
                    && c[6] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('a')
                    && c[2] == QLatin1Char('c') && c[3] == QLatin1Char('k')
                    && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('g')
                    && c[6] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('i') && c[3] == QLatin1Char('v')
                    && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('t')
                    && c[6] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 8: {
        if (c[0] == QLatin1Char('c') && c[1] == QLatin1Char('o')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('i') && c[5] == QLatin1Char('n')
                && c[6] == QLatin1Char('u') && c[7] == QLatin1Char('e'))
            return QScriptGrammar::T_CONTINUE;
        else if (c[0] == QLatin1Char('f') && c[1] == QLatin1Char('u')
                && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n'))
            return QScriptGrammar::T_FUNCTION;
        else if (c[0] == QLatin1Char('d') && c[1] == QLatin1Char('e')
                && c[2] == QLatin1Char('b') && c[3] == QLatin1Char('u')
                && c[4] == QLatin1Char('g') && c[5] == QLatin1Char('g')
                && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('r'))
            return QScriptGrammar::T_DEBUGGER;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('a') && c[1] == QLatin1Char('b')
                    && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('a')
                    && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('v') && c[1] == QLatin1Char('o')
                    && c[2] == QLatin1Char('l') && c[3] == QLatin1Char('a')
                    && c[4] == QLatin1Char('t') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('l') && c[7] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 9: {
        if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                    && c[2] == QLatin1Char('t') && c[3] == QLatin1Char('e')
                    && c[4] == QLatin1Char('r') && c[5] == QLatin1Char('f')
                    && c[6] == QLatin1Char('a') && c[7] == QLatin1Char('c')
                    && c[8] == QLatin1Char('e'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('t') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('a') && c[3] == QLatin1Char('n')
                    && c[4] == QLatin1Char('s') && c[5] == QLatin1Char('i')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('t'))
                return QScriptGrammar::T_RESERVED_WORD;
            else if (c[0] == QLatin1Char('p') && c[1] == QLatin1Char('r')
                    && c[2] == QLatin1Char('o') && c[3] == QLatin1Char('t')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('c')
                    && c[6] == QLatin1Char('t') && c[7] == QLatin1Char('e')
                    && c[8] == QLatin1Char('d'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 10: {
        if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('n')
                && c[2] == QLatin1Char('s') && c[3] == QLatin1Char('t')
                && c[4] == QLatin1Char('a') && c[5] == QLatin1Char('n')
                && c[6] == QLatin1Char('c') && c[7] == QLatin1Char('e')
                && c[8] == QLatin1Char('o') && c[9] == QLatin1Char('f'))
            return QScriptGrammar::T_INSTANCEOF;
        else if (check_reserved) {
            if (c[0] == QLatin1Char('i') && c[1] == QLatin1Char('m')
                    && c[2] == QLatin1Char('p') && c[3] == QLatin1Char('l')
                    && c[4] == QLatin1Char('e') && c[5] == QLatin1Char('m')
                    && c[6] == QLatin1Char('e') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('t') && c[9] == QLatin1Char('s'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    case 12: {
        if (check_reserved) {
            if (c[0] == QLatin1Char('s') && c[1] == QLatin1Char('y')
                    && c[2] == QLatin1Char('n') && c[3] == QLatin1Char('c')
                    && c[4] == QLatin1Char('h') && c[5] == QLatin1Char('r')
                    && c[6] == QLatin1Char('o') && c[7] == QLatin1Char('n')
                    && c[8] == QLatin1Char('i') && c[9] == QLatin1Char('z')
                    && c[10] == QLatin1Char('e') && c[11] == QLatin1Char('d'))
                return QScriptGrammar::T_RESERVED_WORD;
        }
    }   break;

    } // switch

    return -1;
}

int QScript::Lexer::lex()
{
    int token = 0;
    state = Start;
    ushort stringType = 0; // either single or double quotes
    pos8 = pos16 = 0;
    done = false;
    terminator = false;

    // did we push a token on the stack previously ?
    // (after an automatic semicolon insertion)
    if (stackToken >= 0) {
        setDone(Other);
        token = stackToken;
        stackToken = -1;
    }

    while (!done) {
        switch (state) {
        case Start:
            if (isWhiteSpace()) {
                // do nothing
            } else if (current == '/' && next1 == '/') {
                recordStartPos();
                shift(1);
                Q_ASSERT(pos16 == 0);
                state = InSingleLineComment;
            } else if (current == '/' && next1 == '*') {
                recordStartPos();
                shift(1);
                Q_ASSERT(pos16 == 0);
                state = InMultiLineComment;
            } else if (current == 0) {
                syncProhibitAutomaticSemicolon();
                if (!terminator && !delimited && !prohibitAutomaticSemicolon) {
                    // automatic semicolon insertion if program incomplete
                    token = QScriptGrammar::T_SEMICOLON;
                    stackToken = 0;
                    setDone(Other);
                } else {
                    setDone(Eof);
                }
            } else if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
                yycolumn = 0;
                bol = true;
                terminator = true;
                syncProhibitAutomaticSemicolon();
                if (restrKeyword) {
                    token = QScriptGrammar::T_SEMICOLON;
                    setDone(Other);
                }
            } else if (current == '"' || current == '\'') {
                recordStartPos();
                state = InString;
                stringType = current;
            } else if (isIdentLetter(current)) {
                recordStartPos();
                record16(current);
                state = InIdentifier;
            } else if (current == '0') {
                recordStartPos();
                record8(current);
                state = InNum0;
            } else if (isDecimalDigit(current)) {
                recordStartPos();
                record8(current);
                state = InNum;
            } else if (current == '.' && isDecimalDigit(next1)) {
                recordStartPos();
                record8(current);
                state = InDecimal;
            } else {
                recordStartPos();
                token = matchPunctuator(current, next1, next2, next3);
                if (token != -1) {
                    if (terminator && !delimited && !prohibitAutomaticSemicolon
                        && (token == QScriptGrammar::T_PLUS_PLUS
                            || token == QScriptGrammar::T_MINUS_MINUS)) {
                        // automatic semicolon insertion
                        stackToken = token;
                        token = QScriptGrammar::T_SEMICOLON;
                    }
                    setDone(Other);
                }
                else {
                    setDone(Bad);
                    err = IllegalCharacter;
                    errmsg = LU::tr("Illegal character");
                }
            }
            break;
        case InString:
            if (current == stringType) {
                shift(1);
                setDone(String);
            } else if (current == 0 || isLineTerminator()) {
                setDone(Bad);
                err = UnclosedStringLiteral;
                errmsg = LU::tr("Unclosed string at end of line");
            } else if (current == '\\') {
                state = InEscapeSequence;
            } else {
                record16(current);
            }
            break;
            // Escape Sequences inside of strings
        case InEscapeSequence:
            if (isOctalDigit(current)) {
                if (current >= '0' && current <= '3' &&
                     isOctalDigit(next1) && isOctalDigit(next2)) {
                    record16(convertOctal(current, next1, next2));
                    shift(2);
                    state = InString;
                } else if (isOctalDigit(current) &&
                            isOctalDigit(next1)) {
                    record16(convertOctal('0', current, next1));
                    shift(1);
                    state = InString;
                } else if (isOctalDigit(current)) {
                    record16(convertOctal('0', '0', current));
                    state = InString;
                } else {
                    setDone(Bad);
                    err = IllegalEscapeSequence;
                    errmsg = LU::tr("Illegal escape sequence");
                }
            } else if (current == 'x')
                state = InHexEscape;
            else if (current == 'u')
                state = InUnicodeEscape;
            else {
                record16(singleEscape(current));
                state = InString;
            }
            break;
        case InHexEscape:
            if (isHexDigit(current) && isHexDigit(next1)) {
                state = InString;
                record16(QLatin1Char(convertHex(current, next1)));
                shift(1);
            } else if (current == stringType) {
                record16(QLatin1Char('x'));
                shift(1);
                setDone(String);
            } else {
                record16(QLatin1Char('x'));
                record16(current);
                state = InString;
            }
            break;
        case InUnicodeEscape:
            if (isHexDigit(current) && isHexDigit(next1) &&
                 isHexDigit(next2) && isHexDigit(next3)) {
                record16(convertUnicode(current, next1, next2, next3));
                shift(3);
                state = InString;
            } else if (current == stringType) {
                record16(QLatin1Char('u'));
                shift(1);
                setDone(String);
            } else {
                setDone(Bad);
                err = IllegalUnicodeEscapeSequence;
                errmsg = LU::tr("Illegal unicode escape sequence");
            }
            break;
        case InSingleLineComment:
            if (isLineTerminator()) {
                record16(current); // include newline
                processComment(buffer16, pos16);
                shiftWindowsLineBreak();
                yylineno++;
                yycolumn = 0;
                pos16 = 0;
                terminator = true;
                bol = true;
                if (restrKeyword) {
                    token = QScriptGrammar::T_SEMICOLON;
                    setDone(Other);
                } else
                    state = Start;
            } else if (current == 0) {
                setDone(Eof);
            } else {
                record16(current);
            }
            break;
        case InMultiLineComment:
            if (current == 0) {
                setDone(Bad);
                err = UnclosedComment;
                errmsg = LU::tr("Unclosed comment at end of file");
            } else if (isLineTerminator()) {
                shiftWindowsLineBreak();
                yylineno++;
            } else if (current == '*' && next1 == '/') {
                processComment(buffer16, pos16);
                pos16 = 0;
                state = Start;
                shift(1);
            } else {
                record16(current);
            }
            break;
        case InIdentifier:
            if (isIdentLetter(current) || isDecimalDigit(current)) {
                record16(current);
                break;
            }
            setDone(Identifier);
            break;
        case InNum0:
            if (current == 'x' || current == 'X') {
                record8(current);
                state = InHex;
            } else if (current == '.') {
                record8(current);
                state = InDecimal;
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else if (isOctalDigit(current)) {
                record8(current);
                state = InOctal;
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InDecimal;
            } else {
                setDone(Number);
            }
            break;
        case InHex:
            if (isHexDigit(current))
                record8(current);
            else
                setDone(Hex);
            break;
        case InOctal:
            if (isOctalDigit(current)) {
                record8(current);
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InDecimal;
            } else {
                setDone(Octal);
            }
            break;
        case InNum:
            if (isDecimalDigit(current)) {
                record8(current);
            } else if (current == '.') {
                record8(current);
                state = InDecimal;
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else {
                setDone(Number);
            }
            break;
        case InDecimal:
            if (isDecimalDigit(current)) {
                record8(current);
            } else if (current == 'e' || current == 'E') {
                record8(current);
                state = InExponentIndicator;
            } else {
                setDone(Number);
            }
            break;
        case InExponentIndicator:
            if (current == '+' || current == '-') {
                record8(current);
            } else if (isDecimalDigit(current)) {
                record8(current);
                state = InExponent;
            } else {
                setDone(Bad);
                err = IllegalExponentIndicator;
                errmsg = LU::tr("Illegal syntax for exponential number");
            }
            break;
        case InExponent:
            if (isDecimalDigit(current)) {
                record8(current);
            } else {
                setDone(Number);
            }
            break;
        default:
            Q_ASSERT_X(0, "Lexer::lex", "Unhandled state in switch statement");
        }

        // move on to the next character
        if (!done)
            shift(1);
        if (state != Start && state != InSingleLineComment)
            bol = false;
    }

    // no identifiers allowed directly after numeric literal, e.g. "3in" is bad
    if ((state == Number || state == Octal || state == Hex)
         && isIdentLetter(current)) {
        state = Bad;
        err = IllegalIdentifier;
        errmsg = LU::tr("Identifier cannot start with numeric literal");
    }

    // terminate string
    buffer8[pos8] = '\0';

    double dval = 0;
    if (state == Number) {
        dval = QByteArray::fromRawData(buffer8, pos8).toDouble();
    } else if (state == Hex) { // scan hex numbers
        dval = QScript::integerFromString(buffer8, pos8, 16);
        state = Number;
    } else if (state == Octal) {   // scan octal number
        dval = QScript::integerFromString(buffer8, pos8, 8);
        state = Number;
    }

    restrKeyword = false;
    delimited = false;

    switch (parenthesesState) {
    case IgnoreParentheses:
        break;
    case CountParentheses:
        if (token == QScriptGrammar::T_RPAREN) {
            --parenthesesCount;
            if (parenthesesCount == 0)
                parenthesesState = BalancedParentheses;
        } else if (token == QScriptGrammar::T_LPAREN) {
            ++parenthesesCount;
        }
        break;
    case BalancedParentheses:
        parenthesesState = IgnoreParentheses;
        break;
    }

    switch (state) {
    case Eof:
        return 0;
    case Other:
        if(token == QScriptGrammar::T_RBRACE || token == QScriptGrammar::T_SEMICOLON)
            delimited = true;
        return token;
    case Identifier:
        if ((token = findReservedWord(buffer16, pos16)) < 0) {
            /* TODO: close leak on parse error. same holds true for String */
            qsyylval = QString(buffer16, pos16);
            return QScriptGrammar::T_IDENTIFIER;
        }
        if (token == QScriptGrammar::T_CONTINUE || token == QScriptGrammar::T_BREAK
            || token == QScriptGrammar::T_RETURN || token == QScriptGrammar::T_THROW) {
            restrKeyword = true;
        } else if (token == QScriptGrammar::T_IF || token == QScriptGrammar::T_FOR
                   || token == QScriptGrammar::T_WHILE || token == QScriptGrammar::T_WITH) {
            parenthesesState = CountParentheses;
            parenthesesCount = 0;
        } else if (token == QScriptGrammar::T_DO) {
            parenthesesState = BalancedParentheses;
        }
        return token;
    case String:
        qsyylval = QString(buffer16, pos16);
        return QScriptGrammar::T_STRING_LITERAL;
    case Number:
        qsyylval = dval;
        return QScriptGrammar::T_NUMERIC_LITERAL;
    case Bad:
        return -1;
    default:
        Q_ASSERT(!"unhandled numeration value in switch");
        return -1;
    }
}

bool QScript::Lexer::isWhiteSpace() const
{
    return (current == ' ' || current == '\t' ||
             current == 0x0b || current == 0x0c);
}

bool QScript::Lexer::isLineTerminator() const
{
    return (current == '\n' || current == '\r');
}

bool QScript::Lexer::isIdentLetter(ushort c)
{
    /* TODO: allow other legitimate unicode chars */
    return ((c >= 'a' && c <= 'z')
            || (c >= 'A' && c <= 'Z')
            || c == '$'
            || c == '_');
}

bool QScript::Lexer::isDecimalDigit(ushort c)
{
    return (c >= '0' && c <= '9');
}

bool QScript::Lexer::isHexDigit(ushort c) const
{
    return ((c >= '0' && c <= '9')
            || (c >= 'a' && c <= 'f')
            || (c >= 'A' && c <= 'F'));
}

bool QScript::Lexer::isOctalDigit(ushort c) const
{
    return (c >= '0' && c <= '7');
}

int QScript::Lexer::matchPunctuator(ushort c1, ushort c2,
                            ushort c3, ushort c4)
{
    if (c1 == '>' && c2 == '>' && c3 == '>' && c4 == '=') {
        shift(4);
        return QScriptGrammar::T_GT_GT_GT_EQ;
    } else if (c1 == '=' && c2 == '=' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_EQ_EQ_EQ;
    } else if (c1 == '!' && c2 == '=' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_NOT_EQ_EQ;
    } else if (c1 == '>' && c2 == '>' && c3 == '>') {
        shift(3);
        return QScriptGrammar::T_GT_GT_GT;
    } else if (c1 == '<' && c2 == '<' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_LT_LT_EQ;
    } else if (c1 == '>' && c2 == '>' && c3 == '=') {
        shift(3);
        return QScriptGrammar::T_GT_GT_EQ;
    } else if (c1 == '<' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_LE;
    } else if (c1 == '>' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_GE;
    } else if (c1 == '!' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_NOT_EQ;
    } else if (c1 == '+' && c2 == '+') {
        shift(2);
        return QScriptGrammar::T_PLUS_PLUS;
    } else if (c1 == '-' && c2 == '-') {
        shift(2);
        return QScriptGrammar::T_MINUS_MINUS;
    } else if (c1 == '=' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_EQ_EQ;
    } else if (c1 == '+' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_PLUS_EQ;
    } else if (c1 == '-' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_MINUS_EQ;
    } else if (c1 == '*' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_STAR_EQ;
    } else if (c1 == '/' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_DIVIDE_EQ;
    } else if (c1 == '&' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_AND_EQ;
    } else if (c1 == '^' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_XOR_EQ;
    } else if (c1 == '%' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_REMAINDER_EQ;
    } else if (c1 == '|' && c2 == '=') {
        shift(2);
        return QScriptGrammar::T_OR_EQ;
    } else if (c1 == '<' && c2 == '<') {
        shift(2);
        return QScriptGrammar::T_LT_LT;
    } else if (c1 == '>' && c2 == '>') {
        shift(2);
        return QScriptGrammar::T_GT_GT;
    } else if (c1 == '&' && c2 == '&') {
        shift(2);
        return QScriptGrammar::T_AND_AND;
    } else if (c1 == '|' && c2 == '|') {
        shift(2);
        return QScriptGrammar::T_OR_OR;
    }

    switch(c1) {
        case '=': shift(1); return QScriptGrammar::T_EQ;
        case '>': shift(1); return QScriptGrammar::T_GT;
        case '<': shift(1); return QScriptGrammar::T_LT;
        case ',': shift(1); return QScriptGrammar::T_COMMA;
        case '!': shift(1); return QScriptGrammar::T_NOT;
        case '~': shift(1); return QScriptGrammar::T_TILDE;
        case '?': shift(1); return QScriptGrammar::T_QUESTION;
        case ':': shift(1); return QScriptGrammar::T_COLON;
        case '.': shift(1); return QScriptGrammar::T_DOT;
        case '+': shift(1); return QScriptGrammar::T_PLUS;
        case '-': shift(1); return QScriptGrammar::T_MINUS;
        case '*': shift(1); return QScriptGrammar::T_STAR;
        case '/': shift(1); return QScriptGrammar::T_DIVIDE_;
        case '&': shift(1); return QScriptGrammar::T_AND;
        case '|': shift(1); return QScriptGrammar::T_OR;
        case '^': shift(1); return QScriptGrammar::T_XOR;
        case '%': shift(1); return QScriptGrammar::T_REMAINDER;
        case '(': shift(1); return QScriptGrammar::T_LPAREN;
        case ')': shift(1); return QScriptGrammar::T_RPAREN;
        case '{': shift(1); return QScriptGrammar::T_LBRACE;
        case '}': shift(1); return QScriptGrammar::T_RBRACE;
        case '[': shift(1); return QScriptGrammar::T_LBRACKET;
        case ']': shift(1); return QScriptGrammar::T_RBRACKET;
        case ';': shift(1); return QScriptGrammar::T_SEMICOLON;

        default: return -1;
    }
}

ushort QScript::Lexer::singleEscape(ushort c) const
{
    switch(c) {
    case 'b':
        return 0x08;
    case 't':
        return 0x09;
    case 'n':
        return 0x0A;
    case 'v':
        return 0x0B;
    case 'f':
        return 0x0C;
    case 'r':
        return 0x0D;
    case '"':
        return 0x22;
    case '\'':
        return 0x27;
    case '\\':
        return 0x5C;
    default:
        return c;
    }
}

ushort QScript::Lexer::convertOctal(ushort c1, ushort c2,
                            ushort c3) const
{
    return ((c1 - '0') * 64 + (c2 - '0') * 8 + c3 - '0');
}

unsigned char QScript::Lexer::convertHex(ushort c)
{
    if (c >= '0' && c <= '9')
        return (c - '0');
    else if (c >= 'a' && c <= 'f')
        return (c - 'a' + 10);
    else
        return (c - 'A' + 10);
}

unsigned char QScript::Lexer::convertHex(ushort c1, ushort c2)
{
    return ((convertHex(c1) << 4) + convertHex(c2));
}

QChar QScript::Lexer::convertUnicode(ushort c1, ushort c2,
                             ushort c3, ushort c4)
{
    return QChar((convertHex(c3) << 4) + convertHex(c4),
                  (convertHex(c1) << 4) + convertHex(c2));
}

void QScript::Lexer::record8(ushort c)
{
    Q_ASSERT(c <= 0xff);

    // enlarge buffer if full
    if (pos8 >= size8 - 1) {
        char *tmp = new char[2 * size8];
        memcpy(tmp, buffer8, size8 * sizeof(char));
        delete [] buffer8;
        buffer8 = tmp;
        size8 *= 2;
    }

    buffer8[pos8++] = (char) c;
}

void QScript::Lexer::record16(QChar c)
{
    // enlarge buffer if full
    if (pos16 >= size16 - 1) {
        QChar *tmp = new QChar[2 * size16];
        memcpy(tmp, buffer16, size16 * sizeof(QChar));
        delete [] buffer16;
        buffer16 = tmp;
        size16 *= 2;
    }

    buffer16[pos16++] = c;
}

void QScript::Lexer::recordStartPos()
{
    startlineno = yylineno;
    startcolumn = yycolumn;
}

bool QScript::Lexer::scanRegExp(RegExpBodyPrefix prefix)
{
    pos16 = 0;
    bool lastWasEscape = false;

    if (prefix == EqualPrefix)
        record16(QLatin1Char('='));

    while (1) {
        if (isLineTerminator() || current == 0) {
            errmsg = LU::tr("Unterminated regular expression literal");
            return false;
        }
        else if (current != '/' || lastWasEscape == true)
            {
                record16(current);
                lastWasEscape = !lastWasEscape && (current == '\\');
            }
        else {
            pattern = QString(buffer16, pos16);
            pos16 = 0;
            shift(1);
            break;
        }
        shift(1);
    }

    flags = 0;
    while (isIdentLetter(current)) {
        record16(current);
        shift(1);
    }

    return true;
}

void QScript::Lexer::syncProhibitAutomaticSemicolon()
{
    if (parenthesesState == BalancedParentheses) {
        // we have seen something like "if (foo)", which means we should
        // never insert an automatic semicolon at this point, since it would
        // then be expanded into an empty statement (ECMA-262 7.9.1)
        prohibitAutomaticSemicolon = true;
        parenthesesState = IgnoreParentheses;
    } else {
        prohibitAutomaticSemicolon = false;
    }
}

void QScript::Lexer::processComment(const QChar *chars, int length)
{
    commentProcessor->processComment(chars, length);
}


class Translator;

class QScriptParser: protected QScriptGrammar, public QScript::CommentProcessor
{
public:
    QVariant val;

    struct Location {
      int startLine;
      int startColumn;
      int endLine;
      int endColumn;
    };

public:
    QScriptParser();
    ~QScriptParser();

    void setLexer(QScript::Lexer *);
    void setTranslator(Translator *);

    bool parse();

    QString fileName() const
    { return lexer->fileName(); }
    inline QString errorMessage() const
    { return error_message; }
    inline int errorLineNumber() const
    { return error_lineno; }
    inline int errorColumnNumber() const
    { return error_column; }

protected:
    inline void reallocateStack();

    inline QVariant &sym(int index)
    { return sym_stack [tos + index - 1]; }

    inline Location &loc(int index)
    { return location_stack [tos + index - 2]; }

    std::ostream &yyMsg(int line = 0);

    virtual void processComment(const QChar *, int);

protected:
    int tos;
    int stack_size;
    QVector<QVariant> sym_stack;
    int *state_stack;
    Location *location_stack;
    QString error_message;
    int error_lineno;
    int error_column;

private:
    QScript::Lexer *lexer;
    Translator *translator;
    QString trcontext;
    QString extracomment;
    QString msgid;
    QString sourcetext;
    TranslatorMessage::ExtraData extra;
};

inline void QScriptParser::reallocateStack()
{
    if (! stack_size)
        stack_size = 128;
    else
        stack_size <<= 1;

    sym_stack.resize(stack_size);
    state_stack = reinterpret_cast<int*> (realloc(state_stack, stack_size * sizeof(int)));
    location_stack = reinterpret_cast<Location*> (realloc(location_stack, stack_size * sizeof(Location)));
}

inline static bool automatic(QScript::Lexer *lexer, int token)
{
    return (token == QScriptGrammar::T_RBRACE)
        || (token == 0)
        || lexer->prevTerminator();
}

QScriptParser::QScriptParser():
    tos(0),
    stack_size(0),
    sym_stack(0),
    state_stack(0),
    location_stack(0),
    lexer(0),
    translator(0)
{
}

QScriptParser::~QScriptParser()
{
    if (stack_size) {
        free(state_stack);
        free(location_stack);
    }
}

static inline QScriptParser::Location location(QScript::Lexer *lexer)
{
    QScriptParser::Location loc;
    loc.startLine = lexer->startLineNo();
    loc.startColumn = lexer->startColumnNo();
    loc.endLine = lexer->endLineNo();
    loc.endColumn = lexer->endColumnNo();
    return loc;
}

void QScriptParser::setLexer(QScript::Lexer *lex)
{
    lexer = lex;
}

void QScriptParser::setTranslator(Translator *tor)
{
    translator = tor;
}

bool QScriptParser::parse()
{
  Q_ASSERT(lexer != 0);
  Q_ASSERT(translator != 0);
  trcontext = QFileInfo(fileName()).baseName();

  const int INITIAL_STATE = 0;

  int yytoken = -1;
  int saved_yytoken = -1;
  int identLineNo = -1;

  reallocateStack();

  tos = 0;
  state_stack[++tos] = INITIAL_STATE;

  while (true)
    {
      const int state = state_stack [tos];
      if (yytoken == -1 && - TERMINAL_COUNT != action_index [state])
        {
          if (saved_yytoken == -1)
            {
              yytoken = lexer->lex();
              location_stack [tos] = location(lexer);
            }
          else
            {
              yytoken = saved_yytoken;
              saved_yytoken = -1;
            }
        }

      int act = t_action (state, yytoken);

      if (act == ACCEPT_STATE)
        return true;

      else if (act > 0)
        {
          if (++tos == stack_size)
            reallocateStack();

          sym_stack [tos] = lexer->val ();
          state_stack [tos] = act;
          location_stack [tos] = location(lexer);
          yytoken = -1;
        }

      else if (act < 0)
        {
          int r = - act - 1;

          tos -= rhs [r];
          act = state_stack [tos++];

          switch (r) {

case 1: {
    sym(1) = sym(1).toByteArray();
    identLineNo = lexer->startLineNo();
} break;

case 7: {
  bool rx = lexer->scanRegExp(QScript::Lexer::NoPrefix);
  if (!rx) {
      error_message = lexer->errorMessage();
      error_lineno = lexer->startLineNo();
      error_column = lexer->startColumnNo();
      return false;
  }
} break;

case 8: {
  bool rx = lexer->scanRegExp(QScript::Lexer::EqualPrefix);
  if (!rx) {
      error_message = lexer->errorMessage();
      error_lineno = lexer->startLineNo();
      error_column = lexer->startColumnNo();
      return false;
  }
} break;

case 66: {
    QString name = sym(1).toString();
    if ((name == QLatin1String("qsTranslate")) || (name == QLatin1String("QT_TRANSLATE_NOOP"))) {
        if (!sourcetext.isEmpty())
            yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").arg(name));
        QVariantList args = sym(2).toList();
        if (args.size() < 2) {
            yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least two arguments.\n").arg(name));
        } else {
            if ((args.at(0).type() != QVariant::String)
                || (args.at(1).type() != QVariant::String)) {
                yyMsg(identLineNo) << qPrintable(LU::tr("%1(): both arguments must be literal strings.\n").arg(name));
            } else {
                QString context = args.at(0).toString();
                QString text = args.at(1).toString();
                QString comment = args.value(2).toString();
                bool plural = (args.size() > 4);
                recordMessage(translator, context, text, comment, extracomment,
                              msgid, extra, plural, fileName(), identLineNo);
            }
        }
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    } else if ((name == QLatin1String("qsTr")) || (name == QLatin1String("QT_TR_NOOP"))) {
        if (!sourcetext.isEmpty())
            yyMsg(identLineNo) << qPrintable(LU::tr("//% cannot be used with %1(). Ignoring\n").arg(name));
        QVariantList args = sym(2).toList();
        if (args.size() < 1) {
            yyMsg(identLineNo) << qPrintable(LU::tr("%1() requires at least one argument.\n").arg(name));
        } else {
            if (args.at(0).type() != QVariant::String) {
                yyMsg(identLineNo) << qPrintable(LU::tr("%1(): text to translate must be a literal string.\n").arg(name));
            } else {
                QString text = args.at(0).toString();
                QString comment = args.value(1).toString();
                bool plural = (args.size() > 2);
                recordMessage(translator, trcontext, text, comment, extracomment,
                              msgid, extra, plural, fileName(), identLineNo);
            }
        }
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    }
} break;

case 70: {
    sym(1) = QVariantList();
} break;

case 71: {
    sym(1) = sym(2);
} break;

case 72: {
    sym(1) = QVariantList() << sym(1);
} break;

case 73: {
    sym(1) = sym(1).toList() << sym(3);
} break;

case 94: {
    if ((sym(1).type() == QVariant::String) || (sym(3).type() == QVariant::String))
        sym(1) = QVariant(sym(1).toString() + sym(3).toString());
    else
        sym(1) = QVariant();
} break;

    case 171:

    case 172:

    case 173:

    case 174:

    case 175:

    case 176:

    case 177:

    case 178:

    case 179:

    case 180:

    case 181:

    case 182:

    case 183:

    case 184:

    case 185:
    if (!sourcetext.isEmpty() || !extracomment.isEmpty() || !msgid.isEmpty() || !extra.isEmpty()) {
        yyMsg() << qPrintable(LU::tr("Discarding unconsumed meta data\n"));
        sourcetext.clear();
        extracomment.clear();
        msgid.clear();
        extra.clear();
    }
    break;

          } // switch

          state_stack [tos] = nt_action (act, lhs [r] - TERMINAL_COUNT);

          if (rhs[r] > 1) {
              location_stack[tos - 1].endLine = location_stack[tos + rhs[r] - 2].endLine;
              location_stack[tos - 1].endColumn = location_stack[tos + rhs[r] - 2].endColumn;
              location_stack[tos] = location_stack[tos + rhs[r] - 1];
          }
        }

      else
        {
          if (saved_yytoken == -1 && automatic (lexer, yytoken) && t_action (state, T_AUTOMATIC_SEMICOLON) > 0)
            {
              saved_yytoken = yytoken;
              yytoken = T_SEMICOLON;
              continue;
            }

          else if ((state == INITIAL_STATE) && (yytoken == 0)) {
              // accept empty input
              yytoken = T_SEMICOLON;
              continue;
          }

          int ers = state;
          int shifts = 0;
          int reduces = 0;
          int expected_tokens [3];
          for (int tk = 0; tk < TERMINAL_COUNT; ++tk)
            {
              int k = t_action (ers, tk);

              if (! k)
                continue;
              else if (k < 0)
                ++reduces;
              else if (spell [tk])
                {
                  if (shifts < 3)
                    expected_tokens [shifts] = tk;
                  ++shifts;
                }
            }

          error_message.clear ();
          if (shifts && shifts < 3)
            {
              bool first = true;

              for (int s = 0; s < shifts; ++s)
                {
                  if (first) {
                    error_message += QLatin1String ("Expected ");
                    //: Beginning of the string that contains
                    //: comma-separated list of expected tokens
                    error_message += LU::tr("Expected ");
                  } else {
                    error_message += QLatin1String (", ");
                  }

                  first = false;
                  error_message += QLatin1String("`");
                  error_message += QLatin1String (spell [expected_tokens [s]]);
                  error_message += QLatin1String("'");
                }
            }

          if (error_message.isEmpty())
              error_message = lexer->errorMessage();

          error_lineno = lexer->startLineNo();
          error_column = lexer->startColumnNo();

          return false;
        }
    }

    return false;
}

std::ostream &QScriptParser::yyMsg(int line)
{
    return std::cerr << qPrintable(fileName()) << ':' << (line ? line : lexer->startLineNo()) << ": ";
}

void QScriptParser::processComment(const QChar *chars, int length)
{
    if (!length)
        return;
    // Try to match the logic of the C++ parser.
    if (*chars == QLatin1Char(':') && chars[1].isSpace()) {
        extracomment += QString(chars+2, length-2);
    } else if (*chars == QLatin1Char('=') && chars[1].isSpace()) {
        msgid = QString(chars+2, length-2).simplified();
    } else if (*chars == QLatin1Char('~') && chars[1].isSpace()) {
        QString text = QString(chars+2, length-2).trimmed();
        int k = text.indexOf(QLatin1Char(' '));
        if (k > -1)
            extra.insert(text.left(k), text.mid(k + 1).trimmed());
    } else if (*chars == QLatin1Char('%') && chars[1].isSpace()) {
        sourcetext.reserve(sourcetext.length() + length-2);
        ushort *ptr = (ushort *)sourcetext.data() + sourcetext.length();
        int p = 2, c;
        forever {
            if (p >= length)
                break;
            c = chars[p++].unicode();
            if (isspace(c))
                continue;
            if (c != '"') {
                yyMsg() << qPrintable(LU::tr("Unexpected character in meta string\n"));
                break;
            }
            forever {
                if (p >= length) {
                  whoops:
                    yyMsg() << qPrintable(LU::tr("Unterminated meta string\n"));
                    break;
                }
                c = chars[p++].unicode();
                if (c == '"')
                    break;
                if (c == '\\') {
                    if (p >= length)
                        goto whoops;
                    c = chars[p++].unicode();
                    if (c == '\n')
                        goto whoops;
                    *ptr++ = '\\';
                }
                *ptr++ = c;
            }
        }
        sourcetext.resize(ptr - (ushort *)sourcetext.data());
    } else {
        int idx = 0;
        ushort c;
        while ((c = chars[idx].unicode()) == ' ' || c == '\t' || c == '\n')
            ++idx;
        if (!memcmp(chars + idx, MagicComment.unicode(), MagicComment.length() * 2)) {
            idx += MagicComment.length();
            QString comment = QString(chars + idx, length - idx).simplified();
            int k = comment.indexOf(QLatin1Char(' '));
            if (k == -1) {
                trcontext = comment;
            } else {
                trcontext = comment.left(k);
                comment.remove(0, k + 1);
                TranslatorMessage msg(
                        trcontext, QString(),
                        comment, QString(),
                        fileName(), lexer->startLineNo(), QStringList(),
                        TranslatorMessage::Finished, /*plural=*/false);
                msg.setExtraComment(extracomment.simplified());
                extracomment.clear();
                translator->append(msg);
                translator->setExtras(extra);
                extra.clear();
            }
        }
    }
}


bool loadQScript(Translator &translator, const QString &filename, ConversionData &cd)
{
    QFile file(filename);
    if (!file.open(QIODevice::ReadOnly)) {
        cd.appendError(LU::tr("Cannot open %1: %2").arg(filename, file.errorString()));
        return false;
    }
    QTextStream ts(&file);
    QByteArray codecName;
    if (!cd.m_codecForSource.isEmpty())
        codecName = cd.m_codecForSource;
    else
        codecName = translator.codecName(); // Just because it should be latin1 already
    ts.setCodec(QTextCodec::codecForName(codecName));
    ts.setAutoDetectUnicode(true);

    QString code = ts.readAll();
    QScriptParser parser;
    QScript::Lexer lexer(&parser);
    lexer.setCode(code, filename, /*lineNumber=*/1);
    parser.setLexer(&lexer);
    parser.setTranslator(&translator);
    if (!parser.parse()) {
        std::cerr << qPrintable(filename) << ':' << parser.errorLineNumber() << ": "
                  << qPrintable(parser.errorMessage()) << std::endl;
        return false;
    }

    // Java uses UTF-16 internally and Jambi makes UTF-8 for tr() purposes of it.
    translator.setCodecName("UTF-8");
    return true;
}

QT_END_NAMESPACE

#endif // QSCRIPT_CPP

